{"version":3,"sources":["components/Pattern.js","components/Main.js","App.js","serviceWorker.js","index.js"],"names":["Pattern","renderPattern","patternDivs","time","_this","props","pattern","i","push","react_default","a","createElement","className","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_step","_loop","e","value","startTime","split","startTimeConvert","parseInt","endTime","endTimeConvert","newDiv","map","div","_iterator","Symbol","iterator","next","done","err","return","date","this","React","Component","Main","state","tempNap","nap","patterns","handleSubmit","event","preventDefault","Object","objectSpread","toConsumableArray","length","window","alert","setState","indexOfPattern","findIndex","prevState","ls","set","handleChange","_event$target","target","name","get","rendPatterns","sort","b","Date","components_Pattern","Fragment","onSubmit","type","onChange","App","components_Main","Boolean","location","hostname","match","ReactDOM","render","src_App","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.72e2baad.chunk.js","sourcesContent":["import React from 'react'\n\nclass Pattern extends React.Component {\n\n    renderPattern = () => {\n        let patternDivs = []\n        const { time } = this.props.pattern\n\n        // draw empty bar\n        for (let i = 0; i < 1440; i++) {\n            patternDivs.push(<div className=\"standard-div\">&nbsp;</div>)\n        }\n\n        // draw green bar for each nap\n        for (let e of time) {\n            // convert nap time to numbers and then set how many minutes passed since 0:00\n            // nap start time\n            let startTime = e[0].split(':') //[\"01\", \"00\"]\n            const startHours = parseInt(startTime[0], 10)\n            const startMinutes = parseInt(startTime[1], 10)\n            const startTimeConvert = startHours * 60 + startMinutes\n\n            // convert nap time to numbers and then set how many minutes passed since 0:00\n            // nap end time\n            const endTime = e[1].split(':')\n            const endHours = parseInt(endTime[0], 10)\n            const endMinutes = parseInt(endTime[1], 10)\n            const endTimeConvert = endHours * 60 + endMinutes\n\n            // new progress bar with naps\n            const newDiv = patternDivs.map((div, i) => {\n                if (i >= startTimeConvert && i <= endTimeConvert) {\n                    return <div className=\"nap-div\">&nbsp;</div>\n                } else {\n                    return div\n                }\n            })\n            patternDivs = newDiv\n        }\n        return patternDivs\n    }\n\n    render() {\n        const { date } = this.props.pattern\n\n        return (\n            <div>\n                {date} <br />\n                <div className=\"display-bar\">\n                    {this.renderPattern()}\n                </div>\n            </div>\n        )\n    }\n}\n\nexport default Pattern\n\n    // displayPattern = (start, end) => {\n\n    //     let displayBar = []\n    //     const startTime = start.split(':')\n    //     const startHours = parseInt(startTime[0], 10)\n    //     const startMinutes = parseInt(startTime[1], 10)\n    //     const startTimeConvert = startHours * 60 + startMinutes\n    //     console.log(startTimeConvert)\n\n    //     const endTime = end.split(':')\n    //     const endHours = parseInt(endTime[0], 10)\n    //     const endMinutes = parseInt(endTime[1], 10)\n    //     const endTimeConvert = endHours * 60 + endMinutes\n    //     console.log(endTimeConvert)\n\n    //     for (let i = 0; i < 1440; i++) {\n    //         // if (i < startTimeConvert || i > endTimeConvert) {\n    //         //     displayBar.push(<td>-</td>)\n    //         // } else {\n    //         //     displayBar.push(<td>+</td>)\n    //         // }\n\n    //         if (i < startTimeConvert || i > endTimeConvert) {\n    //             displayBar.push(<div style={{backgroundColor: \"grey\", width: \"0.5px\"}}>&nbsp;</div>)\n    //         } else {\n    //             displayBar.push(<div style={{ backgroundColor: \"green\", width: \"0.5px\"}}>&nbsp;</div>)\n    //         }\n    //     }\n\n    //     return displayBar\n    // }","import React from 'react'\nimport Pattern from './Pattern'\nimport ls from 'local-storage'\n\nclass Main extends React.Component {\n\n    state = {\n        tempNap: {\n            date: \"\",\n            nap: [\"\", \"\"]\n        },\n        patterns: []\n\n        // how single pattern should look like\n        // {\n        //     date: null,\n        //     time: [[1:00, 2:00], [7:00, 10:00]]\n        // }\n    }\n\n    // check if there are any patterns in local storage\n    componentDidMount() {\n        // if there are none then create empty array prepared to store patterns\n        if (ls.get('patterns') === null || ls.get('patterns').length === 0) {\n            ls.set('patterns', [])\n        } else {\n            // get patterns from local storage and inject them into app\n            this.setState({ patterns: [...ls.get('patterns')] })\n        }\n    }\n\n\n    handleSubmit = (event) => {\n        event.preventDefault()\n\n        const tempNap = { ...this.state.tempNap }\n        const patterns = [...this.state.patterns]\n\n        // check if nap end is later than nap start\n        if (tempNap.nap[1] <= tempNap.nap[0] && tempNap.nap[1].length > 0) {\n            window.alert('Nap must end later than it started')\n            tempNap.nap[1] = \"\"\n            this.setState({ tempNap: tempNap })\n        } else {\n            // add nap to patterns and clear temporary nap\n            const indexOfPattern = patterns.findIndex(pattern => pattern.date === tempNap.date)\n\n            if (indexOfPattern !== -1) {\n                patterns[indexOfPattern].time.push(tempNap.nap)\n            } else {\n                patterns.push({ date: tempNap.date, time: [tempNap.nap] })\n            }\n\n            this.setState((prevState) => {\n                return {\n                    patterns: [...patterns],\n                    tempNap: {\n                        date: \"\",\n                        nap: [\"\", \"\"]\n                    }\n                }\n            })\n\n            // save patterns to local storage\n            ls.set('patterns', [...patterns])\n        }\n    }\n\n    handleChange = (event) => {\n        event.preventDefault()\n        const { name, value } = event.target\n        let tempNap = { ...this.state.tempNap }\n\n        switch (name) {\n            case \"day\":\n                tempNap.date = value\n                break;\n            case \"start-time\":\n                tempNap.nap[0] = value\n                break;\n            case \"end-time\":\n                tempNap.nap[1] = value\n                break;\n\n            default:\n                break;\n        }\n\n        // TO HANDLE WRONG INPUT IN REAL TIME\n        // if(tempNap.nap[1] <= tempNap.nap[0] && tempNap.nap[1].length > 0) {\n        //     window.alert('Nap must end later than it started')\n        //     tempNap.nap[1] = \"\"\n        // }\n\n        this.setState({ tempNap: tempNap })\n    }\n\n    render() {\n        // preparing pattern list to display, sorted from newest to oldest\n        const rendPatterns = this.state.patterns\n            .sort((a, b) => new Date(b.date) - new Date(a.date))\n            .map(\n                pattern => <Pattern pattern={pattern} />\n            )\n\n        return (\n            <React.Fragment>\n                <form onSubmit={this.handleSubmit}>\n                    <label>Day?\n                        <input\n                            type=\"date\"\n                            name=\"day\"\n                            onChange={this.handleChange}\n                            value={this.state.tempNap.date} />\n                    </label>\n                    <label>Start time:\n                        <input\n                            type=\"time\"\n                            name=\"start-time\"\n                            onChange={this.handleChange}\n                            value={this.state.tempNap.nap[0]} />\n                    </label>\n                    <label>End time:\n                        <input\n                            type=\"time\"\n                            name=\"end-time\"\n                            onChange={this.handleChange}\n                            value={this.state.tempNap.nap[1]} />\n                    </label>\n                    <button type=\"submit\">Add nap</button>\n                </form>\n\n                <div className=\"output\">\n                    {rendPatterns}\n                </div>\n            </React.Fragment>\n        )\n    }\n}\n\nexport default Main\n\n\n    // ---------------------------\n    // MANAGE ADDING PATTERNS BY CLICKING ONLY ONE BUTTON: STATE\n    // ---------------------------\n\n    // isStart: true,\n    // tempPattern: {\n    //     date: null,\n    //     start: [],\n    //     end: []\n    // },\n    // patterns: []\n\n    // ---------------------------\n    // MANAGE ADDING PATTERNS BY CLICKING ONLY ONE BUTTON\n    // ---------------------------\n\n    // addDate = () => {\n    //     if (this.state.isStart) {\n    //         let time = new Date()\n    //         this.setState(prevState => ({\n    //             tempPattern: {...prevState.tempPattern, date: time, start: [time.getHours(), time.getMinutes(), time.getSeconds()]},\n    //             isStart: !prevState.isStart\n    //         }))\n    //     } else {\n    //         let time = new Date()\n    //         this.setState(prevState => ({\n    //             tempPattern: { ...prevState.tempPattern, end: [time.getHours(), time.getMinutes(), time.getSeconds()]},\n    //             isStart: !prevState.isStart\n    //         }))\n    //         this.setState(prevState => ({\n    //             patterns: [...prevState.patterns, prevState.tempPattern],\n    //             tempPattern: {\n    //                 date: null,\n    //                 start: [],\n    //                 end: []\n    //             }\n    //         }))\n    //     }","import React from 'react';\nimport Main from './components/Main'\nimport './App.css';\n\nfunction App() {\n  return (\n   <Main />\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}